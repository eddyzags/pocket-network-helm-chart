# Helm Chart package for Pocket Network

{{ template "chart.versionBadge" . }}{{ template "chart.typeBadge" . }}{{ template "chart.appVersionBadge" . }}

Pocket Network is permissionless decentralized physical infrastructure (DePin) protocol that incentivizes and coordinates a network of node operators to provide open data access to anyone. This repository bootstraps a Pocket Network deployment on a Kubernetes cluster using the Helm package manager.

[Overview of Pocket Network](https://pocket.network/)

## TL;DR
```shell
?> helm install release-1 https://github.com/eddyzags/pocket-network-helm-charts
```

## Introduction

## Prerequisites
* Kubernetes 1.23+
* Helm 3.9.0+
* Provisionning keys for Pocket Network Kubernetes Pods (e.g fullnode and relayminer)

## Installing the Chart

To install the chart with name `my-release`
```
helm install my-release https://github.com/eddyzags/pocket-network-helm-charts --values shannon-values.yaml
```
> Note: You must specify the value in yaml file. This is an example with the values related to Shannon protocol.

This command deploy the different Pocket Network actors based on the values provided in the 

## Configuration and installation details

### Provisionning keys

This section refers to the key management capabilities this chart offers to configure each instance of the Pocket Network which are essential for signing transactions and managing accounts on a Cosmos-based blockchain. 

#### Relayminer

In Pocket Network, all relayminers needs a signing key to sign each relays he serves with a private key. Therefore, each key name listed in `shannon.relayminer.config.default_signing_key_names` must be present in the keyring backend used to start the Relayminer instances.
This example demonstrates how to provision a key through Kubernetes secret while using a `keyring-backend=test`:

```
shannon:
  relayminer:
    secret:
      # defines the type of resources the chart needs to mount for the
      # fullnode to access the network credentials.
      type: Secret
      # represents the secret metadata.
      key:
        name: pocket-network-release-1-shannon-relayminer
        keyName: supplier1.info
```

> Note: Every signing key names (`shannon.relayminer.config.default_signing_key_names`) must have a corresponding secret that matches the keyName. Therefore, if I have `shannon.relayminer.config.default_signing_key_names=["relayminer"], we must provide a secret with `shannon.relayminer.secret.key.keyName="relayminer.info"`

#### Fullnode

A Shannon Fullnode requires two important key files. The node key as a unique identifier for your node on the P2P network used solely for identifying and authenticating with others, and the validator private key used for signing consensus messages (e.g. block proposals, votes). This example demonstrates how to provision a node and validator private key for a fullnode:

```
shannon:
  fullnode:
    combetbft:
      secret:
        type: Secret
        key:
          name: pocket-network-release-1-shannon
          nodeKeyName: node_key.json
          privValidatorKeyName: priv_validator_key.json
```

### Resources and limits

Pocket Network charts allow setting resource requests and limits for every protocol actors (containers) inside the chart deployment. There are inside the `resources` values.
To make this resource and limit definition easier to define, this chart contains a `resources.preset` attribute that sets the `resources.limits` and `resources.requests`. These presets are recommended by the community, but you can define your own.

> Note: You can either define a preset (`resources.preset=small` for example) or an explicit . If you define both, the `resources.limits` and `resources.requests` will be used.

### Fullnode Persistence

The Shannon Full node images stores the various runtime data such as state information, configuration files, and other crucial data required for the operation of a node inside the `.Values.homeDirectory/data` path of the container. This chart provides multiple options to manage this volume for the fullnode

* Option A) Use an empty data directory to start the fullnode on a clean slate. This can be useful for test purposes.

```
shannon:
  fullnode:
    storage:
      data:
      enabled: false
```

> Note: This options doesn't persistent the data across deployments. In other words, if the Kubernetes Pod restarts, you will loose all your data.

* Option B) Use a Persistent Volume Claim (PVC) to start the fullnode on a clean slate, or an existing slate. Persistent Volume Claims are used to keep data across deployments. This integration is known to work in Google Cloud Platform (GCP), Amazon Web services (AWS), on-premise, and minikube.

```
shannon:
  fullnode:
    storage:
      data:
      enabled: true
      volumeClaimTemplate:
        annotations: {}
        accessModes: ["ReadWriteOnce"]
        storageClassName: ""
        selector:
          matchLabels:
            app.pocket.network: pocket-network-pv-shannon
        volumeMode: Filesystem
        resources:
          requests:
            storage: 1000Gi
          limits:
            storage: 1500Gi
```

#### Adjust permissions of persistent volume mountpoint

As the image run as non-root by default, it is necessary to adjust the ownership of the persistent volume so that the container process can write data into it. Follow this link to know which UID and GID is configured by default for [ghcr.io/pokt-network/pocketd](https://github.com/pokt-network/poktroll/blob/3ba0390f66636f16441bbf53950ae4c8990479ca/Dockerfile.release#L11-L12)

### Prometheus metrics

This chart can be integrated with Prometheus by setting `metrics.enabled` to `true`. This will expose a prometheus metrics endpoint, and a `ServiceMonitor` object. This chart will define the necessary configurations to be automatically scraped by Prometheus.

> Note: it is necessary to have a working installation of Prometheus Operator for the integration to work.

### Accessing Pocket Network Services from outside the cluster

#TODO(eddyzags): define integration with ingress

## Parameters

{{ define "chart.valueDefaultColumnRender" }}
{{- $defaultValue := (default .Default .AutoDefault)  -}}
{{- $notationType := .NotationType }}
{{- if (and (hasPrefix "`" $defaultValue) (hasSuffix "`" $defaultValue) ) -}}
{{- $defaultValue = (toPrettyJson (fromJson (trimAll "`" (default .Default .AutoDefault) ) ) ) -}}
{{- $notationType = "json" }}
{{- end -}}
{{- if (eq $notationType "tpl" ) }}
<pre lang="{{ $notationType }}">
{{ .Key }}: |
  {{ $defaultValue  }}
</pre>
{{- else if (eq $notationType "toml") }}
<a href="./shannon-values.yaml">see example in shannon-values.yaml</a>
{{- else if (eq $notationType "email") }}
<a href="mailto:{{ $defaultValue }}" style="color: green;">"{{ $defaultValue }}"</a>
{{- else }}
<pre lang="{{ $notationType }}">
{{ $defaultValue }}
</pre>
{{- end }}
{{ end }}

{{ define "chart.typeColumnRender" }}
{{- if (eq .Type "string/email") }}
<a href="#stringemail" title="{{- template "chart.valuetypes.email" -}}">{{.Type}}</a>
{{- else if (eq .Type "k8s/storage/persistent-volume/access-modes" )}}
<a target="_blank" 
   href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes"
   >{{- .Type }}</a>
{{- else }}
{{ .Type }}
{{- end }}
{{ end }}

{{ define "chart.valuesTableHtml" }}
<table height="400px" >
	<thead>
		<th>Key</th>
		<th>Type</th>
		<th>Default</th>
		<th>Description</th>
	</thead>
	<tbody>
	{{- range .Values }}
		<tr>
			<td id="{{ .Key | replace "." "--" }}">{{ .Key }}</td>
			<td>{{- template "chart.typeColumnRender" . -}}</td>
			<td>
				<div style="max-width: 300px;">{{ template "chart.valueDefaultColumnRender" . }}</div>
			</td>
			<td>{{ if .Description }}{{ .Description }}{{ else }}{{ .AutoDescription }}{{ end }}</td>
		</tr>
	{{- end }}
	</tbody>
</table>
{{ end }}

{{ template "chart.valuesSectionHtml" . }}