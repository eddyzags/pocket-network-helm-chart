# Default values for Shannon.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# protocol string refers to the decentralized framework that enables applications
# to access reliable and censorship-resistant infrastructure (e.g. shannon or morse).
# This chart only supports shannon for now.
protocol: shannon

# chain string refers to the different chain of the Pocket Network protocol.
# (e.g. pocket-beta, pocket-alpha, pocket)
#
# see https://dev.poktroll.com/category/networks
chain: pocket-beta

# version string refers to the unique version of the pocketd computer
# software.
#
# see https://github.com/pokt-network/poktroll/releases
version: 0.1.21

# workingDirectory refers to the pocketd working directory. This variable is
# shared across all every procol actors. Meaning that the working directory
# will be instantiated in the same path for every 
workingDirectory: /home/pocket/.pocket

# `shannon` object defines the root-level configuration values for the Shannon
# protocol. It specifies the configuration for all protocol actors and is
# required when `.Values.protocol` is set to `shannon`
#
# see https://dev.poktroll.com/category/protocol-actors for more information.
shannon:
  # relayminer defines the configuration values of the specialized node
  # (off-chain actor) to expose services through Pocket Network.
  #
  # see https://dev.poktroll.com/protocol/actors/relay_miner
  relayminer:
    # activates the deployment of a relayminer and its dependencies.
    enabled: false
    # grpcInsecure allows gRPC over insecure channels for querying state in the CosmosSDK.
    #
    # see https://dev.poktroll.com/operate/cheat_sheets/supplier_cheatsheet#secure-vs-non-secure-query_node_grpc_url
    grpcInsecure: true
    # gasAdjustment refers to the adjustement factor to be multiplied by the gas
    # estmiation given by the tx simulation.
    #
    # see https://docs.cosmos.network/main/learn/beginner/tx-lifecycle#gas-and-fees
    gasAdjustment: 1.5
    # gasPrices specifies how much you are willing to pay per unit of gas.
    #
    # see https://docs.cosmos.network/main/learn/beginner/tx-lifecycle#gas-and-fees
    gasPrices: 0.0001upokt
    # configures the `pocketd` application instrumentation.
    telemetry:
      # logs refers to the logging configuration
      logs:
        # level defines the log severity.
        #
        # see https://github.com/pokt-network/poktroll/blob/6759eec9f586358a12306fa8c92d18cb03ef6530/pkg/polylog/polyzero/levels.go#L39-L54
        level: info
    # configures the storage backend for the keyring implementation for
    # the relayminer.
    #
    # e.g.:
    #
    # keyring:
    #   backend: test
    #   secrets:
    #     - name: pocket-network-shannon-relayminer-keys-6d75d3784282
    #       keyNames:
    #         - 712748083b46.info
    #         - d05e660a522a.info
    #     - name: pocket-network-shannon-relayminer-keys-a1773588ce07
    #       keyNames:
    #         - 679f41b29fd7.info
    #         - 8598780fc3df.info
    keyring:
      # select the storage backend to use for the keyring. This charts only support the
      # 'test' keyring backend for now.
      #
      # see https://docs.cosmos.network/v0.46/run-node/keyring.html#available-backends-for-the-keyring
      backend: test
      # defines the Kubernetes Secret keys to mount into the relayminer
      # Kubernetes Pod.
      # The `keyNames` string values must be unique across every referenced
      # Kubernetes Secrets to avoid collision because they will all be
      # mounted into the same directory (.Values.workingDirectory/keyring-test).
      secrets:
        - name: pocket-network-shannon-relayminer-key
          keyNames:
            - supplier1.info
    # config defines key-values pairs for the relayminer main configuration.
    #
    # see https://dev.poktroll.com/operate/configs/relayminer_config
    #
    # -- (tpl/string)
    # @notationType -- toml
    config:
      # default_signing_key_names defines the list of key names to load into
      # the relayminer application from the keyring storage backend.
      # Make sure to configure the `.Values.relayminer.keyring` accordingly.
      # 
      # https://dev.poktroll.com/operate/configs/relayminer_config
      default_signing_key_names: [supplier1]
      # smt_store_path path to the working directory for Sparse Merkle Tree.
      # It is recommended to have inside the `.Values.workingDirectory`
      # directory.
      smt_store_path: /home/pocket/.pocket/smt
      # pocket_node defines the different connectivity for the pocketd node.
      #
      # see https://dev.poktroll.com/operate/configs/relayminer_config#pocket-node-connectivity
      pocket_node:
        # query_node_rpc_url sets a websocket connection to a pocket network node.
        #
        # see https://dev.poktroll.com/operate/configs/relayminer_config#query_node_rpc_url
        query_node_rpc_url: tcp://node:26657
        # query_node_grpc_url sets a rpc connection to a pocket network node to read Pocket Network's data.
        #
        # see https://dev.poktroll.com/operate/configs/relayminer_config#query_node_rpc_url
        query_node_grpc_url: tcp://node:9090
        # tx_node_rpc_url sets a rpc connection to a pocket node endpoint to write Pocket Network's data.
        #
        # see https://dev.poktroll.com/operate/configs/relayminer_config#tx_node_rpc_url
        tx_node_rpc_url: tcp://node:26657
      # suppliers defines a list of key-values pairs to define the services managed
      # by the relayminer.
      #
      # Fore more informatino about what a supplier is, please see
      # https://dev.poktroll.com/protocol/actors/supplier
      #
      # e.g.
      #
      # suppliers:
      #   - service_id: ollama
      #     service_config:
      #      backend_url: http://ollama:8547/
      #      authentication:
      #        username: user1
      #        password: pass1
      #      headers:
      #        header1: value1
      #      forward_pocket_headers: true
      #     listen_url: http://0.0.0.0:8546
      #   - service_id: anvil
      #     service_config:
      #      backend_url: http://anvil:8547/
      #      authentication:
      #        username: user2
      #        password: pass2
      #      headers:
      #        header2: value2
      #      forward_pocket_headers: true
      #     listen_url: http://0.0.0.0:8546
      #
      # For more information about the configuration, please see
      # https://dev.poktroll.com/operate/configs/relayminer_config#suppliers
      suppliers:
        # service_id is a unique identifier to reference a service provided by
        # this relayminer.
      - service_id: anvil
        # service_config configures the supplier of this service.
        #
        # see https://dev.poktroll.com/operate/configs/relayminer_config#service_config
        service_config:
          # backend_url is the endpoint to which the relays will be forwarded to for
          # this service.
          backend_url: http://anvil:8547/
        # listen_url is the address from which the relayminer application will
        # start a server to listen for incoming relays for this service.
        #
        # see https://dev.poktroll.com/operate/configs/relayminer_config#listen_url
        listen_url: http://0.0.0.0:8545
      # metrics configures a Prometheus Exporter server for prometheus collector to
      # read the relayminer application metrics.
      metrics:
        # activates a Prometheus Exporter endpoint.
        enabled: true
        # addr is the address and port at which the server must bind to.
        addr: :9090
      # pprof configures a pprof server for visualization and analysis of
      # profiling data.
      pprof:
        # enabled activates a pprof server.
        enabled: true
        # addr is the address at which the server must bind to.
        addr: :6060
      # ping configures a ping healh check server to test the connectivity of all backend URLs
      # https://dev.poktroll.com/operate/configs/relayminer_config#ping
      ping:
        # enabled activates the ping server.
        enabled: true
        # addr is the address at which the server must listen.
        addr: :8081
    cometbft:
      # -- (tpl/string)
      # @notationType -- toml
      clientConfig: |
        # specifies the broadcast mode for the TxService.Broadcast RPC
        broadcast-mode = "sync"
        # name of the targeted chain to send transaction
        chain-id = "pocket-beta"
        # specifies where keys are stored
        keyring-backend = "test"
        # rpc interface for the specified chain.
        node = "tcp://node:26657"
        # client output format (json|text)
        output = "json"
    # prometheus is the root value configuration for prometheus operator.
    prometheus:
      # configures for a Prometheus Operator ServiceMonitor custom resource.
      serviceMonitor:
        # activates the templating of a ServiceMonitor custom resource.
        enabled: true
    # development are the globals configuration to set up an development
    # environment on the relayminer pod.
    development:
      # delve configures a debugger for the Go programming language. Keep in
      # mind that debugging may be challenging if the binary was compiled
      # with optimizations and inlining enabled.
      #
      # see https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_exec.md
      delve:
        # activates the `pocketd` binary with delve.
        enabled: false
        # addr is the address where the delve server bind to.
        addr: :40004
        # headless runs debug server only, in headless mode.
        headless: true
        # apiVersion selects JSON-RPC API version when headless.
        apiVersion: 2
        # acceptMulticlient allows a headless server to accept multiple client
        # connections via JSON-RPC or DAP.
        acceptMulticlient: true
    # image is the root configuration for the container image to be used for the
    # relayminer.
    image:
      # repository defines which container image will be pulled from a container
      # registry.
      repository: ghcr.io/pokt-network/pocketd
     # pullPolicy defines the pull policy for the relayminer.
      pullPolicy: IfNotPresent
      # tag overrides the image tag. If not tag are defined, the chart will use
      # the `.Values.version` value as default.
      tag: ""
    # replicas defines the number of instances for the relayminer.
    # Right now, the relayminer does't scale horizontally.
    replicas: 1
    # imagePullSecrets defines the information to authenticate with the
    # container registry.
    imagePullSecrets: []
    # configures the relayminer resource limits.
    resources:
      # preset defines the resource pre-configuration (cpu and memory) for the
      # relayminer (small, medium, large or none).
      preset:
        # activates the preset definition for the relayminer Kubernetes Pod.
        # If activated, this chart will discard every values inside
        # `.Values.relayminer.resources`.
        enabled: false
        # select the preset to use for the relayminer pod template.
        name: medium
      values:
        # defines the request resources limits for the relayminer Kubernetes Pod.
        requests:
          # defines the cpu request limit.
          cpu: 2000m
          # defines the memory request limit.
          memory: 3Gi
        # defines the limits resources limit for the relayminer Kubernetes Pod.
        limits:
          # defines the cpu limit.
          cpu: 3000m
          # defines the memory limit.
          memory: 6Gi
    # configures a Kubernetes Service for every ports exposed by the
    # relayminer application.
    service:
      # type defines the type of service we want to use for the relayminer ports
      # (ClusterIP, NodePort, etc...).
      #
      # see https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
      type: ClusterIP
    # volumes are the additional volume for the relayminer pod.
    volumes: []
    # volumeMounts are the additional volume mount point for the relayminer pod.
    #
    # e.g.
    #
    # - name: foo
    #   mountPath: "/etc/foo"
    #   readOnly: true
    volumeMounts: []
    # configures a ingress resource to enable external access to services for
    # the relayminer.
    #
    # https://kubernetes.io/docs/concepts/services-networking/ingress
    ingress:
      # activates the definition of an ingress resource.
      enabled: false
      # controls how the ingress resource is dynamically provisioned.
      className: ""
      # defines non-selectable metadata attached to the ingress resource
      # for the relayminer.
      annotations: {}
      # secures an ingress host by specifying a Secret that contains a TLS
      # private key and certificates.
      #
      # https://kubernetes.io/docs/concepts/services-networking/ingress/#tls
      #
      # e.g
      #
      # tls:
      #   - https-example.foo.com
      # secretName: testsecret-tls
      tls: []
      # defines the hostnames this ingress rule applies to.
      #
      # e.g
      #
      # hosts:
      #   - host: relayminer.pocket.network
      #     paths:
      #       - path: /
      #         pathType: Prefix
      #         backend:
      #           service:
      #             name: relayminer-service
      #             port:
      #               number: 8080
      hosts: []
    # configures the routine that checks whether the relayminer container is healthy.
    livenessProbe:
      # ping configures a probe against the ping server in the relayminer. Make
      # sure to active the ping server in `.shannon.relayminer.config.ping`,
      # otherwise the livesness probe won't be defined even if it is enbaled.
      # 
      # https://dev.poktroll.com/operate/configs/relayminer_config#ping
      ping:
        # activates a http client to send request to the ping server.
        enabled: false
        # initial number of seconds to wait after the container starts the 
        # liveness probe.
        initialDelaySeconds: 10
        # defines how often the kubelet performs health checks in seconds.
        periodSeconds: 15
    # autoscaling is the root configuration for the HorizontalPodAutoscaler.
    autoscaling:
      # enable activates the templating of a HorizontalPodAutoscaler resource.
      enabled: false
      # minReplicas defines the minimum number of replicas that should be maintained.
      minReplicas: 1
      # maxReplicas defines the maximum number of replicas that the HPA can
      # scale up to when the demand increases.
      maxReplicas: 100
      # targetCPUUtilizationPercentage defines the percentage of requested CPU
      # usage across all pods.
      targetCPUUtilizationPercentage: 80
      # targetMemoryUtilizationPercentage defines the percentage of requested
      # memory usage across all pods.
      targetMemoryUtilizationPercentage: 80
    # podAnnotations are key-values pairs metadata attched to Pods.
    #
    # e.g.
    #
    # podAnnotations:
    #   version: "1.2.3"
    #   commitHash: "abc123def456"
    podAnnotations: {}
    # podSecurityContext are key-values pairs to define the security settings
    # for all containers within a pod.
    #
    # e.g.
    #
    # podSecurityContext
    #   runAsUser: 1000         # Run the Pod as user ID 1000
    #   runAsGroup: 3000        # Run the Pod as group ID 3000
    #   fsGroup: 2000           # Set file system group ownership to 2000
    podSecurityContext: {}
    # initContainersSecurityContext are key-values pairs to define the
    # security settings for all init containers. This field overwrites
    # the podSecurityContext settings if any defined.
    #
    # e.g.
    #
    # initContainers:
    #   runAsUser: 1000         # Run the Pod as user ID 1000
    #   runAsGroup: 3000        # Run the Pod as group ID 3000
    #   fsGroup: 2000           # Set file system group ownership to 2000
    initContainersSecurityContext:
      runAsUser: 1025
      runAsGroup: 1025
    # securityContext are key-values pairs to define the security settings
    # for the relayminer pod containers. This field overwrites the
    # podSecurityContext settings if any defined.
    #
    # e.g.
    #
    # capabilities:
    #     drop:
    #     - ALL
    #   readOnlyRootFilesystem: true
    #   runAsNonRoot: true
    #   runAsUser: 1000
    containersSecurityContext: {}
    # nodeSelector are key-values pairs to schedule the relayminer pod on a
    # specific node based on labels.
    nodeSelector: {}
    # affinity defines the settings for complex scheduling preferences.
    affinity: {}
    # tolerations defines policies for taints.
    tolerations: []
  # defines the configuration values of the fullnode (on-chain actor) to expose
  # services through Pocket Network.
  #
  # see https://dev.poktroll.com/operate/cheat_sheets/full_node_cheatsheet
  fullnode:
    # activates the deployment of a fullnode.
    enabled: true
    # configures a wrapper process manager for CosmosSDK application binaries.
    #
    # see https://docs.cosmos.network/main/build/tooling/cosmovisor
    cosmosvisor:
      # activates the deployment of cosmosvisor.
      enabled: false
      # refers to the cosmosvisor working directory (default '.Values.workingDirectory').
      workingDirectory: ""
      # disables cosmosvisor logs.
      disableLogs: false
      # colorise cosmosvisor logs.
      colorLogs: true
      # defines log format.
      timeformatLogs: kitchen
      # executes a custom script prior to upgrade.
      customPreupgrade: ""
      # matches the upgrade plan name without any case changes.
      disableRecase: false
      # customizing the cosmosvisor daemon.
      daemon:
        # name of the binary to execute as a subprocess of cosmosvisor.
        name: "pocketd"
        # activates auto download of binaries.
        allowDownloadBinaries: true
        # automatically restarts the pocketd subprocess with the same
        # arguments after an upgrade.
        restartAfterUpgrade: true
        # upgrade directly without performing backup.
        unsafeSkipBackup: true
        # interval length for polling the upgrade plan file.
        pollInterval: 300ms
        # maximum number of time to call `pre-upgrade`.
        preupgradeMaxRetries: 0
        # requires that checksum is provided.
        downloadMustHaveChecksum: false
        # delay between node halt (for upgrade) and backup by the specified time.
        restartDelay: ""
        # defines custom backup directory.
        dataBackupDir: ""
    # defines key-pairs values to configure every related to the CosmosSDK framework.
    cosmossdk:
      # configures the cosmossdk and cometBFT configuration files for the
      # fullnode application.
      volumes:
        # activates the import of the configuration from an external source.
        enabled: false
        # defines the type of resources the chart needs to mount for the
        # fullnode Kubernetes Pod to access the configuration files.
        type: ConfigMap
        config:
          key:
            # refers the Kubernetes ConfigMap resource name to use.
            name: pocket-network-fullnode-shannon
            # refers the key name to use in the Kubernetes ConfigMap for the
            # basic cometBFT configuration.
            configKeyName: config.toml
            # refers the key name to use in the Kubernetes ConfigMap for the
            # `pocketd` CLI.
            clientKeyName: client.toml
            # refers the key name to use in the Kubernetes ConfigMap for the
            # application-level settings.
            appKeyName: app.toml
      # -- (tpl/string)
      # @notationType -- toml
      config: |
        # This is a TOML config file.
        # For more information, see https://github.com/toml-lang/toml

        # NOTE: Any path below can be absolute (e.g. "/var/myawesomeapp/data") or
        # relative to the home directory (e.g. "data"). The home directory is
        # "$HOME/.cometbft" by default, but could be changed via $CMTHOME env variable
        # or --home cmd flag.

        # The version of the CometBFT binary that created or
        # last modified the config file. Do not modify this.
        version = "0.38.10"

        #######################################################################
        ###                   Main Base Config Options                      ###
        #######################################################################

        # TCP or UNIX socket address of the ABCI application,
        # or the name of an ABCI application compiled in with the CometBFT binary
        proxy_app = "tcp://127.0.0.1:26658"

        # A custom human readable name for this node
        moniker = "node1"

        # Database backend: goleveldb | cleveldb | boltdb | rocksdb | badgerdb
        # * goleveldb (github.com/syndtr/goleveldb - most popular implementation)
        #   - pure go
        #   - stable
        # * cleveldb (uses levigo wrapper)
        #   - fast
        #   - requires gcc
        #   - use cleveldb build tag (go build -tags cleveldb)
        # * boltdb (uses etcd's fork of bolt - github.com/etcd-io/bbolt)
        #   - EXPERIMENTAL
        #   - may be faster is some use-cases (random reads - indexer)
        #   - use boltdb build tag (go build -tags boltdb)
        # * rocksdb (uses github.com/tecbot/gorocksdb)
        #   - EXPERIMENTAL
        #   - requires gcc
        #   - use rocksdb build tag (go build -tags rocksdb)
        # * badgerdb (uses github.com/dgraph-io/badger)
        #   - EXPERIMENTAL
        #   - use badgerdb build tag (go build -tags badgerdb)
        db_backend = "goleveldb"

        # Database directory
        db_dir = "data"

        # Output level for logging, including package level options
        log_level = "info"

        # Output format: 'plain' (colored text) or 'json'
        log_format = "plain"

        ##### additional base config options #####

        # Path to the JSON file containing the initial validator set and other meta data
        genesis_file = "config/genesis.json"

        # Path to the JSON file containing the private key to use as a validator in the consensus protocol
        priv_validator_key_file = "config/priv_validator_key.json"

        # Path to the JSON file containing the last sign state of a validator
        priv_validator_state_file = "data/priv_validator_state.json"

        # TCP or UNIX socket address for CometBFT to listen on for
        # connections from an external PrivValidator process
        priv_validator_laddr = ""

        # Path to the JSON file containing the private key to use for node authentication in the p2p protocol
        node_key_file = "config/node_key.json"

        # Mechanism to connect to the ABCI application: socket | grpc
        abci = "socket"

        # If true, query the ABCI app on connecting to a new peer
        # so the app can decide if we should keep the connection or not
        filter_peers = false


        #######################################################################
        ###                 Advanced Configuration Options                  ###
        #######################################################################

        #######################################################
        ###       RPC Server Configuration Options          ###
        #######################################################
        [rpc]

        # TCP or UNIX socket address for the RPC server to listen on
        laddr = "tcp://0.0.0.0:26657"

        # A list of origins a cross-domain request can be executed from
        # Default value '[]' disables cors support
        # Use '["*"]' to allow any origin
        cors_allowed_origins = ["*", ]

        # A list of methods the client is allowed to use with cross-domain requests
        cors_allowed_methods = ["HEAD", "GET", "POST", ]

        # A list of non simple headers the client is allowed to use with cross-domain requests
        cors_allowed_headers = ["Origin", "Accept", "Content-Type", "X-Requested-With", "X-Server-Time", ]

        # TCP or UNIX socket address for the gRPC server to listen on
        # NOTE: This server only supports /broadcast_tx_commit
        grpc_laddr = ""

        # Maximum number of simultaneous connections.
        # Does not include RPC (HTTP&WebSocket) connections. See max_open_connections
        # If you want to accept a larger number than the default, make sure
        # you increase your OS limits.
        # 0 - unlimited.
        # Should be < {ulimit -Sn} - {MaxNumInboundPeers} - {MaxNumOutboundPeers} - {N of wal, db and other open files}
        # 1024 - 40 - 10 - 50 = 924 = ~900
        grpc_max_open_connections = 900

        # Activate unsafe RPC commands like /dial_seeds and /unsafe_flush_mempool
        unsafe = false

        # Maximum number of simultaneous connections (including WebSocket).
        # Does not include gRPC connections. See grpc_max_open_connections
        # If you want to accept a larger number than the default, make sure
        # you increase your OS limits.
        # 0 - unlimited.
        # Should be < {ulimit -Sn} - {MaxNumInboundPeers} - {MaxNumOutboundPeers} - {N of wal, db and other open files}
        # 1024 - 40 - 10 - 50 = 924 = ~900
        max_open_connections = 900

        # Maximum number of unique clientIDs that can /subscribe
        # If you're using /broadcast_tx_commit, set to the estimated maximum number
        # of broadcast_tx_commit calls per block.
        max_subscription_clients = 100

        # Maximum number of unique queries a given client can /subscribe to
        # If you're using GRPC (or Local RPC client) and /broadcast_tx_commit, set to
        # the estimated # maximum number of broadcast_tx_commit calls per block.
        max_subscriptions_per_client = 5

        # Experimental parameter to specify the maximum number of events a node will
        # buffer, per subscription, before returning an error and closing the
        # subscription. Must be set to at least 100, but higher values will accommodate
        # higher event throughput rates (and will use more memory).
        experimental_subscription_buffer_size = 200

        # Experimental parameter to specify the maximum number of RPC responses that
        # can be buffered per WebSocket client. If clients cannot read from the
        # WebSocket endpoint fast enough, they will be disconnected, so increasing this
        # parameter may reduce the chances of them being disconnected (but will cause
        # the node to use more memory).
        #
        # Must be at least the same as "experimental_subscription_buffer_size",
        # otherwise connections could be dropped unnecessarily. This value should
        # ideally be somewhat higher than "experimental_subscription_buffer_size" to
        # accommodate non-subscription-related RPC responses.
        experimental_websocket_write_buffer_size = 200

        # If a WebSocket client cannot read fast enough, at present we may
        # silently drop events instead of generating an error or disconnecting the
        # client.
        #
        # Enabling this experimental parameter will cause the WebSocket connection to
        # be closed instead if it cannot read fast enough, allowing for greater
        # predictability in subscription behavior.
        experimental_close_on_slow_client = false

        # How long to wait for a tx to be committed during /broadcast_tx_commit.
        # WARNING: Using a value larger than 10s will result in increasing the
        # global HTTP write timeout, which applies to all connections and endpoints.
        # See https://github.com/tendermint/tendermint/issues/3435
        timeout_broadcast_tx_commit = "10s"

        # Maximum number of requests that can be sent in a batch
        # If the value is set to '0' (zero-value), then no maximum batch size will be
        # enforced for a JSON-RPC batch request.
        max_request_batch_size = 10

        # Maximum size of request body, in bytes
        max_body_bytes = 1000000

        # Maximum size of request header, in bytes
        max_header_bytes = 1048576

        # The path to a file containing certificate that is used to create the HTTPS server.
        # Might be either absolute path or path related to CometBFT's config directory.
        # If the certificate is signed by a certificate authority,
        # the certFile should be the concatenation of the server's certificate, any intermediates,
        # and the CA's certificate.
        # NOTE: both tls_cert_file and tls_key_file must be present for CometBFT to create HTTPS server.
        # Otherwise, HTTP server is run.
        tls_cert_file = ""

        # The path to a file containing matching private key that is used to create the HTTPS server.
        # Might be either absolute path or path related to CometBFT's config directory.
        # NOTE: both tls-cert-file and tls-key-file must be present for CometBFT to create HTTPS server.
        # Otherwise, HTTP server is run.
        tls_key_file = ""

        # pprof listen address (https://golang.org/pkg/net/http/pprof)
        pprof_laddr = ":6060"

        #######################################################
        ###           P2P Configuration Options             ###
        #######################################################
        [p2p]

        # Address to listen for incoming connections
        laddr = "tcp://0.0.0.0:26656"

        # Address to advertise to peers for them to dial. If empty, will use the same
        # port as the laddr, and will introspect on the listener to figure out the
        # address. IP and port are required. Example: 159.89.10.97:26656
        external_address = ""

        # Comma separated list of seed nodes to connect to
        seeds = "78e64eb51f040b86b8e4bed6ba8d895fa2f87839@shannon-grove-seed1.beta.poktroll.com:26656"

        # Comma separated list of nodes to keep persistent connections to
        persistent_peers = ""

        # Path to address book
        addr_book_file = "config/addrbook.json"

        # Set true for strict address routability rules
        # Set false for private or local networks
        addr_book_strict = true

        # Maximum number of inbound peers
        max_num_inbound_peers = 40

        # Maximum number of outbound peers to connect to, excluding persistent peers
        max_num_outbound_peers = 10

        # List of node IDs, to which a connection will be (re)established ignoring any existing limits
        unconditional_peer_ids = ""

        # Maximum pause when redialing a persistent peer (if zero, exponential backoff is used)
        persistent_peers_max_dial_period = "0s"

        # Time to wait before flushing messages out on the connection
        flush_throttle_timeout = "100ms"

        # Maximum size of a message packet payload, in bytes
        max_packet_msg_payload_size = 1024

        # Rate at which packets can be sent, in bytes/second
        send_rate = 5120000

        # Rate at which packets can be received, in bytes/second
        recv_rate = 5120000

        # Set true to enable the peer-exchange reactor
        pex = true

        # Seed mode, in which node constantly crawls the network and looks for
        # peers. If another node asks it for addresses, it responds and disconnects.
        #
        # Does not work if the peer-exchange reactor is disabled.
        seed_mode = false

        # Comma separated list of peer IDs to keep private (will not be gossiped to other peers)
        private_peer_ids = ""

        # Toggle to disable guard against peers connecting from the same ip.
        allow_duplicate_ip = false

        # Peer connection configuration.
        handshake_timeout = "20s"
        dial_timeout = "3s"

        #######################################################
        ###          Mempool Configuration Options          ###
        #######################################################
        [mempool]

        # The type of mempool for this node to use.
        #
        #  Possible types:
        #  - "flood" : concurrent linked list mempool with flooding gossip protocol
        #  (default)
        #  - "nop"   : nop-mempool (short for no operation; the ABCI app is responsible
        #  for storing, disseminating and proposing txs). "create_empty_blocks=false" is
        #  not supported.
        type = "flood"

        # Recheck (default: true) defines whether CometBFT should recheck the
        # validity for all remaining transaction in the mempool after a block.
        # Since a block affects the application state, some transactions in the
        # mempool may become invalid. If this does not apply to your application,
        # you can disable rechecking.
        recheck = true

        # recheck_timeout is the time the application has during the rechecking process
        # to return CheckTx responses, once all requests have been sent. Responses that 
        # arrive after the timeout expires are discarded. It only applies to 
        # non-local ABCI clients and when recheck is enabled.
        #
        # The ideal value will strongly depend on the application. It could roughly be estimated as the
        # average size of the mempool multiplied by the average time it takes the application to validate one
        # transaction. We consider that the ABCI application runs in the same location as the CometBFT binary
        # so that the recheck duration is not affected by network delays when making requests and receiving responses.
        recheck_timeout = "1s"

        # Broadcast (default: true) defines whether the mempool should relay
        # transactions to other peers. Setting this to false will stop the mempool
        # from relaying transactions to other peers until they are included in a
        # block. In other words, if Broadcast is disabled, only the peer you send
        # the tx to will see it until it is included in a block.
        broadcast = true

        # WalPath (default: "") configures the location of the Write Ahead Log
        # (WAL) for the mempool. The WAL is disabled by default. To enable, set
        # WalPath to where you want the WAL to be written (e.g.
        # "data/mempool.wal").
        wal_dir = ""

        # Maximum number of transactions in the mempool
        size = 5000

        # Limit the total size of all txs in the mempool.
        # This only accounts for raw transactions (e.g. given 1MB transactions and
        # max_txs_bytes=5MB, mempool will only accept 5 transactions).
        max_txs_bytes = 1073741824

        # Size of the cache (used to filter transactions we saw earlier) in transactions
        cache_size = 10000

        # Do not remove invalid transactions from the cache (default: false)
        # Set to true if it's not possible for any invalid transaction to become valid
        # again in the future.
        keep-invalid-txs-in-cache = false

        # Maximum size of a single transaction.
        # NOTE: the max size of a tx transmitted over the network is {max_tx_bytes}.
        max_tx_bytes = 1048576

        # Maximum size of a batch of transactions to send to a peer
        # Including space needed by encoding (one varint per transaction).
        # XXX: Unused due to https://github.com/tendermint/tendermint/issues/5796
        max_batch_bytes = 0

        # Experimental parameters to limit gossiping txs to up to the specified number of peers.
        # We use two independent upper values for persistent and non-persistent peers.
        # Unconditional peers are not affected by this feature.
        # If we are connected to more than the specified number of persistent peers, only send txs to
        # ExperimentalMaxGossipConnectionsToPersistentPeers of them. If one of those
        # persistent peers disconnects, activate another persistent peer.
        # Similarly for non-persistent peers, with an upper limit of
        # ExperimentalMaxGossipConnectionsToNonPersistentPeers.
        # If set to 0, the feature is disabled for the corresponding group of peers, that is, the
        # number of active connections to that group of peers is not bounded.
        # For non-persistent peers, if enabled, a value of 10 is recommended based on experimental
        # performance results using the default P2P configuration.
        experimental_max_gossip_connections_to_persistent_peers = 0
        experimental_max_gossip_connections_to_non_persistent_peers = 0

        #######################################################
        ###         State Sync Configuration Options        ###
        #######################################################
        [statesync]
        # State sync rapidly bootstraps a new node by discovering, fetching, and restoring a state machine
        # snapshot from peers instead of fetching and replaying historical blocks. Requires some peers in
        # the network to take and serve state machine snapshots. State sync is not attempted if the node
        # has any local state (LastBlockHeight > 0). The node will have a truncated block history,
        # starting from the height of the snapshot.
        enable = false

        # RPC servers (comma-separated) for light client verification of the synced state machine and
        # retrieval of state data for node bootstrapping. Also needs a trusted height and corresponding
        # header hash obtained from a trusted source, and a period during which validators can be trusted.
        #
        # For Cosmos SDK-based chains, trust_period should usually be about 2/3 of the unbonding time (~2
        # weeks) during which they can be financially punished (slashed) for misbehavior.
        rpc_servers = ""
        trust_height = 0
        trust_hash = ""
        trust_period = "168h0m0s"

        # Time to spend discovering snapshots before initiating a restore.
        discovery_time = "15s"

        # Temporary directory for state sync snapshot chunks, defaults to the OS tempdir (typically /tmp).
        # Will create a new, randomly named directory within, and remove it when done.
        temp_dir = ""

        # The timeout duration before re-requesting a chunk, possibly from a different
        # peer (default: 1 minute).
        chunk_request_timeout = "10s"

        # The number of concurrent chunk fetchers to run (default: 1).
        chunk_fetchers = "4"

        #######################################################
        ###       Block Sync Configuration Options          ###
        #######################################################
        [blocksync]

        # Block Sync version to use:
        #
        # In v0.37, v1 and v2 of the block sync protocols were deprecated.
        # Please use v0 instead.
        #
        #   1) "v0" - the default block sync implementation
        version = "v0"

        #######################################################
        ###         Consensus Configuration Options         ###
        #######################################################
        [consensus]

        wal_file = "data/cs.wal/wal"

        # How long we wait for a proposal block before prevoting nil
        timeout_propose = "5m0s"
        # How much timeout_propose increases with each round
        timeout_propose_delta = "5s"
        # How long we wait after receiving +2/3 prevotes for “anything” (ie. not a single block or nil)
        timeout_prevote = "10s"
        # How much the timeout_prevote increases with each round
        timeout_prevote_delta = "5s"
        # How long we wait after receiving +2/3 precommits for “anything” (ie. not a single block or nil)
        timeout_precommit = "10s"
        # How much the timeout_precommit increases with each round
        timeout_precommit_delta = "5s"
        # How long we wait after committing a block, before starting on the new
        # height (this gives us a chance to receive some more precommits, even
        # though we already have +2/3).
        timeout_commit = "5m0s"

        # How many blocks to look back to check existence of the node's consensus votes before joining consensus
        # When non-zero, the node will panic upon restart
        # if the same consensus key was used to sign {double_sign_check_height} last blocks.
        # So, validators should stop the state machine, wait for some blocks, and then restart the state machine to avoid panic.
        double_sign_check_height = 0

        # Make progress as soon as we have all the precommits (as if TimeoutCommit = 0)
        skip_timeout_commit = false

        # EmptyBlocks mode and possible interval between empty blocks
        create_empty_blocks = true
        create_empty_blocks_interval = "0s"

        # Reactor sleep duration parameters
        peer_gossip_sleep_duration = "100ms"
        peer_query_maj23_sleep_duration = "2s"

        #######################################################
        ###         Storage Configuration Options           ###
        #######################################################
        [storage]

        # Set to true to discard ABCI responses from the state store, which can save a
        # considerable amount of disk space. Set to false to ensure ABCI responses are
        # persisted. ABCI responses are required for /block_results RPC queries, and to
        # reindex events in the command-line tool.
        discard_abci_responses = false

        #######################################################
        ###   Transaction Indexer Configuration Options     ###
        #######################################################
        [tx_index]

        # What indexer to use for transactions
        #
        # The application will set which txs to index. In some cases a node operator will be able
        # to decide which txs to index based on configuration set in the application.
        #
        # Options:
        #   1) "null"
        #   2) "kv" (default) - the simplest possible indexer, backed by key-value storage (defaults to levelDB; see DBBackend).
        # 		- When "kv" is chosen "tx.height" and "tx.hash" will always be indexed.
        #   3) "psql" - the indexer services backed by PostgreSQL.
        # When "kv" or "psql" is chosen "tx.height" and "tx.hash" will always be indexed.
        indexer = "kv"

        # The PostgreSQL connection configuration, the connection format:
        #   postgresql://<user>:<password>@<host>:<port>/<db>?<opts>
        psql-conn = ""

        #######################################################
        ###       Instrumentation Configuration Options     ###
        #######################################################
        [instrumentation]

        # When true, Prometheus metrics are served under /metrics on
        # PrometheusListenAddr.
        # Check out the documentation for the list of available metrics.
        prometheus = true

        # Address to listen for Prometheus collector(s) connections
        prometheus_listen_addr = ":26660"

        # Maximum number of simultaneous connections.
        # If you want to accept a larger number than the default, make sure
        # you increase your OS limits.
        # 0 - unlimited.
        max_open_connections = 3

        # Instrumentation namespace
        namespace = "cometbft"
      # root configuration for fullnode pocket network application such as state
      # prunning strategies, telemetry, gRPC, REST servers, state sync, mempool
      # ect...
      #
      # -- (tpl/string)
      # @notationType -- toml
      app: |
        # This is a TOML config file.
        # For more information, see https://github.com/toml-lang/toml

        ###############################################################################
        ###                           Base Configuration                            ###
        ###############################################################################

        # The minimum gas prices a validator is willing to accept for processing a
        # transaction. A transaction's fees must meet the minimum of any denomination
        # specified in this config (e.g. 0.25token1,0.0001token2).
        minimum-gas-prices = "0.000000001upokt"

        # The maximum gas a query coming over rest/grpc may consume.
        # If this is set to zero, the query can consume an unbounded amount of gas.
        query-gas-limit = "0"

        # default: the last 362880 states are kept, pruning at 10 block intervals
        # nothing: all historic states will be saved, nothing will be deleted (i.e. archiving node)
        # everything: 2 latest states will be kept; pruning at 10 block intervals.
        # custom: allow pruning options to be manually specified through 'pruning-keep-recent', and 'pruning-interval'
        pruning = "nothing"

        # These are applied if and only if the pruning strategy is custom.
        pruning-keep-recent = "0"
        pruning-interval = "0"

        # HaltHeight contains a non-zero block height at which a node will gracefully
        # halt and shutdown that can be used to assist upgrades and testing.
        #
        # Note: Commitment of state will be attempted on the corresponding block.
        halt-height = 0

        # HaltTime contains a non-zero minimum block time (in Unix seconds) at which
        # a node will gracefully halt and shutdown that can be used to assist upgrades
        # and testing.
        #
        # Note: Commitment of state will be attempted on the corresponding block.
        halt-time = 0

        # MinRetainBlocks defines the minimum block height offset from the current
        # block being committed, such that all blocks past this offset are pruned
        # from CometBFT. It is used as part of the process of determining the
        # ResponseCommit.RetainHeight value during ABCI Commit. A value of 0 indicates
        # that no blocks should be pruned.
        #
        # This configuration value is only responsible for pruning CometBFT blocks.
        # It has no bearing on application state pruning which is determined by the
        # "pruning-*" configurations.
        #
        # Note: CometBFT block pruning is dependent on this parameter in conjunction
        # with the unbonding (safety threshold) period, state pruning and state sync
        # snapshot parameters to determine the correct minimum value of
        # ResponseCommit.RetainHeight.
        min-retain-blocks = 0

        # InterBlockCache enables inter-block caching.
        inter-block-cache = true

        # IndexEvents defines the set of events in the form {eventType}.{attributeKey},
        # which informs CometBFT what to index. If empty, all events will be indexed.
        #
        # Example:
        # ["message.sender", "message.recipient"]
        index-events = []

        # IavlCacheSize set the size of the iavl tree cache (in number of nodes).
        iavl-cache-size = 781250

        # IAVLDisableFastNode enables or disables the fast node feature of IAVL.
        # Default is false.
        iavl-disable-fastnode = false

        # AppDBBackend defines the database backend type to use for the application and snapshots DBs.
        # An empty string indicates that a fallback will be used.
        # The fallback is the db_backend value set in CometBFT's config.toml.
        app-db-backend = ""

        ###############################################################################
        ###                         Telemetry Configuration                         ###
        ###############################################################################

        [telemetry]

        # Prefixed with keys to separate services.
        service-name = ""

        # Enabled enables the application telemetry functionality. When enabled,
        # an in-memory sink is also enabled by default. Operators may also enabled
        # other sinks such as Prometheus.
        enabled = false

        # Enable prefixing gauge values with hostname.
        enable-hostname = false

        # Enable adding hostname to labels.
        enable-hostname-label = false

        # Enable adding service to labels.
        enable-service-label = false

        # PrometheusRetentionTime, when positive, enables a Prometheus metrics sink.
        prometheus-retention-time = "1800"

        # GlobalLabels defines a global set of name/value label tuples applied to all
        # metrics emitted using the wrapper functions defined in telemetry package.
        #
        # Example:
        # [["chain_id", "cosmoshub-1"]]
        global-labels = [["chain_id"], ["pocket-beta"]]

        # MetricsSink defines the type of metrics sink to use.
        metrics-sink = "mem"

        # StatsdAddr defines the address of a statsd server to send metrics to.
        # Only utilized if MetricsSink is set to "statsd" or "dogstatsd".
        statsd-addr = ""

        # DatadogHostname defines the hostname to use when emitting metrics to
        # Datadog. Only utilized if MetricsSink is set to "dogstatsd".
        datadog-hostname = ""

        ###############################################################################
        ###                           API Configuration                             ###
        ###############################################################################

        [api]

        # Enable defines if the API server should be enabled.
        enable = true

        # Swagger defines if swagger documentation should automatically be registered.
        swagger = false

        # Address defines the API server to listen on.
        address = "tcp://0.0.0.0:1317"

        # MaxOpenConnections defines the number of maximum open connections.
        max-open-connections = 1000

        # RPCReadTimeout defines the CometBFT RPC read timeout (in seconds).
        rpc-read-timeout = 10

        # RPCWriteTimeout defines the CometBFT RPC write timeout (in seconds).
        rpc-write-timeout = 0

        # RPCMaxBodyBytes defines the CometBFT maximum request body (in bytes).
        rpc-max-body-bytes = 1000000

        # EnableUnsafeCORS defines if CORS should be enabled (unsafe - use it at your own risk).
        enabled-unsafe-cors = true

        ###############################################################################
        ###                           gRPC Configuration                            ###
        ###############################################################################

        [grpc]

        # Enable defines if the gRPC server should be enabled.
        enable = true

        # Address defines the gRPC server address to bind to.
        address = ":9090"

        # MaxRecvMsgSize defines the max message size in bytes the server can receive.
        # The default value is 10MB.
        max-recv-msg-size = "10485760"

        # MaxSendMsgSize defines the max message size in bytes the server can send.
        # The default value is math.MaxInt32.
        max-send-msg-size = "2147483647"

        # SkipCheckHeader defines if the gRPC server should bypass check header.
        skip-check-header = false

        ###############################################################################
        ###                        gRPC Web Configuration                           ###
        ###############################################################################
        [grpc-web]

        # GRPCWebEnable defines if the gRPC-web should be enabled.
        # NOTE: gRPC must also be enabled, otherwise, this configuration is a no-op.
        enable = true
        
        # Address defines the gRPC-web server address to bind to.
        address = ":9091"

        # EnableUnsafeCORS defines if CORS should be enabled (unsafe - use it at your own risk).
        enable-unsafe-cors = true

        ###############################################################################
        ###                        State Sync Configuration                         ###
        ###############################################################################

        # State sync snapshots allow other nodes to rapidly join the network without replaying historical
        # blocks, instead downloading and applying a snapshot of the application state at a given height.
        [state-sync]

        # snapshot-interval specifies the block interval at which local state sync snapshots are
        # taken (0 to disable).
        snapshot-interval = 0

        # snapshot-keep-recent specifies the number of recent snapshots to keep and serve (0 to keep all).
        snapshot-keep-recent = 2

        ###############################################################################
        ###                              State Streaming                            ###
        ###############################################################################

        # Streaming allows nodes to stream state to external systems.
        [streaming]

        # streaming.abci specifies the configuration for the ABCI Listener streaming service.
        [streaming.abci]

        # List of kv store keys to stream out via gRPC.
        # The store key names MUST match the module's StoreKey name.
        #
        # Example:
        # ["acc", "bank", "gov", "staking", "mint"[,...]]
        # ["*"] to expose all keys.
        keys = []

        # The plugin name used for streaming via gRPC.
        # Streaming is only enabled if this is set.
        # Supported plugins: abci
        plugin = ""

        # stop-node-on-err specifies whether to stop the node on message delivery error.
        stop-node-on-err = true

        ###############################################################################
        ###                         Mempool                                         ###
        ###############################################################################

        [mempool]

        # Setting max-txs to 0 will allow for a unbounded amount of transactions in the mempool.
        # Setting max_txs to negative 1 (-1) will disable transactions from being inserted into the mempool (no-op mempool).
        # Setting max_txs to a positive number (> 0) will limit the number of transactions in the mempool, by the specified amount.
        #
        # Note, this configuration only applies to SDK built-in app-side mempool
        # implementations.
        max-txs = 10000

        ###############################################################################
        ###                         Poktroll App Config                             ###
        ###############################################################################

        [poktroll]

          [poktroll.telemetry]

          cardinality-level = "medium"
      # -- (tpl/string)
      # @notationType -- toml
      client: |
        # specifies the broadcast mode for the TxService.Broadcast RPC
        broadcast-mode = "sync"
        # name of the targeted chain to send transaction
        chain-id = "pocket-beta"
        # specifies where keys are stored
        keyring-backend = "test"
        # rpc interface for the specified chain.
        node = "tcp://localhost:26657"
        # client output format (json|text)
        output = "json"
      # define the configuration to provide the keys for the fullnode to
      # authenticated at the consensus layer.
      secret:
        # mounts the Kubernetes Secret for the fullnode authentication keys.
        enabled: false
        # defines the type of resources the chart needs to mount for the
        # fullnode Kubernetes Pod to access the keys.
        type: Secret
        # defines the Kubernetes Secret parameters to references the keys
        # for the fullnode Kubernetes Pod.
        key:
          # defines the name of the Kubernetes Secret resource.
          name: pocket-network-cometbft-keys
          # nodeKeyName is the long term private key for the fullnode.
          # (node-id@host:port).
          nodeKeyName: node_key.json
          # privValidatorKeyName is the long term validator private key for the fullnode.
          privValidatorKeyName: priv_validator_key.json
    # image is the root configuration for the container image to be used for the
    # fullnode.
    image:
      # repository defines which container image will be pulled from a container
      # registry.
      repository: ghcr.io/pokt-network/pocketd
      # tag overrides the image tag. If not tag are defined, the chart will use
      # the .Values.version value as default.
      tag: ""
    # imagePullSecrets defines the information to authenticate with the
    # container registry.
    imagePullSecrets: []
    # configures the `pocketd` application instrumentation.
    telemetry:
      logs:
        # defines the log severity.
        level: info
        # sets the structure of the log.
        format: json
        # disabled colored logs.
        noColor: true
      trace:
        # provides full stack traces for `pocketd`.
        enabled: false
        # enable kvstore tracing to an output file.
        store: ""
    # configures the Kubernetes Service resource to exposed the fullnode
    # application ports.
    service:
      # exposes multiple ports from the fullnode application within the
      # Kubernetes cluster:
      # - RPC: used to query blockchain data, broadcasting transactions.
      # - ABCI: used to communicate with the fullnode ABCI application.
      # - gRPC: used for apps and services to broadcast transactions.
      # - P2P: used to gossip blocks in the consensus layer.
      # - Prometheus: used to exposed the fullnode application metrics.
      # - API: used to query blockchain state via HTTP.
      # - gRPC-app: use for apps and services to interact with the pocket
      #             network chain.
      # - gRPC-web: browser-compatible gRPC.
      local:
        # type defines the type of service we want to use for the fullnode servers
        # (ClusterIP, NodePort, etc...).
        #
        # see https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
        type: ClusterIP
      # exposes the fullnode P2P port outside the Kubernetes cluster to gossip
      # block at the consensus layer.
      external:
        # activates an external access to the fullnode P2P port
        # `.Values.shannon.fullnode.cosmossdk.config.p2p.laddr`.
        enabled: true
        # type defines the type of service we want to use for the fullnode P2P port
        # (ClusterIP, NodePort, etc...).
        #
        # see https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
        type: NodePort
        # p2p represents the service configuration for allowing nodes to
        # connect.
        p2p:
          # defines the port to expose.
          nodePort: 30000
    # tls configures the fullnode to use a transport layer security (TLS) for
    # the RPC server.
    tls:
      # activates the templating to mount a secret into the fullnode Kubernetes
      # Pod for the key and cert file.
      enabled: false
      # defines the Kubernetes Secrets to mount into the fullnode Kubernetes
      # Pod for the certificate.
      secret:
        # defines the Kubernetes Secret parameters to references the certificate
        # for the fullnode Kubernetes Pod.
        key:
          # defines the name of the Kubernetes Secret resource to use.
          name: pocket-network-shannon-fullnode-rpc-tls
          # defines the secret key name to use for the tls cert file.
          certKeyName: tls.crt
          # defines the secret key name to use for the tls key file.
          keyKeyName: tls.key
    # storage is the root configuration for the fullnode persistent volume.
    storage:
      data:
        # activates the mount of an external data directory into the fullnode
        # Kubernetes Pod.
        enabled: false
        # defines a persistent volume claim for the fullnode Kubernetes
        # Statefulset.
        volumeClaimTemplate:
          # defines non-selectable metadata attached to the persistent volume
          # claim template for the fullnode.
          annotations: {}
          # defines how a persistent volume (PV) can be accessed by the fullnode pod.
          accessModes: ["ReadWriteOnce"]
          # controls how the persistent volume claim (PVC) is dynamically provisioned.
          storageClassName: ""
          # used for binding to pre-existing persistent volume (PV) with matching labels.
          selector:
            matchLabels:
              app.pocket.network: pocket-network-test-shannon
          # defines how the volume will be accessed by the fullnode Kubernetes Pod.
          volumeMode: Filesystem
          # defines how big the volume should be for the fullnode pod.
          resources:
            requests:
              storage: 1000Gi
            limits:
              storage: 1500Gi
    # snapshot configures an init container to download the latest blockchain snapshot
    # before executing the fullnode. This can speed up the synchronization of your
    # fullnode.
    snapshot:
      # activates the retrieval of a snapshot before executing the fullnode.
      enabled: false
      # defines the type of tools you want to use to download and extract
      # the blockchain snapshot:
      # - ariac: deploys a one-time init container that uses a lightweight multi-protocol
      #          CLI download utility to fetch the blockchain snapshot. The compressed file is
      #          downloaded to a temporary location and extracted into the fullnode data
      #          directory. Ownership of the data directory can be updated after extraction.
      #          To avoid repeated downloads on each deployment, a unique hidden marker file
      #          named using the '.Values.shannon.fullnode.snapshot.config.url' value is
      #          created after a successful download based on the URL name and used to skip
      #          future ones with the same '.Values.shannon.fullnode.snapshot.config.url'
      #          value. A URL value mismatch will remove the previous snapshot, then trigger
      #          a new snapshot process.
      #
      #          Supported compression algorithm:
      #          - .zst
      #          - .gz
      #
      #          The tarball must match this tree structure:
      #          ├── application.db
      #          │   └── ...
      #          ├── blockstore.db
      #          │   └── ...
      #          ├── evidence.db
      #          │   └── ...
      #          ├── snapshots
      #          │   └── ...
      #          ├── state.db
      #          │   └── ...
      #          └── tx_index.db
      #              └── ...
      #
      #          e.g.
      #          type: ariac
      #          config:
      #            url: https://snapshots.us-nj.poktroll.com/testnet-beta-39120-archival.torrent
      #            chownAsUser: 1025
      #            chownAsGroup: 1025
      #
      # - custom: use a custom init container to fetch and extract a blockchain
      #           snapshot. In some environment, you might want to download a snapshot from a
      #           your own data store or even a object storage service (such as AWS S3).
      #           You can provide your own init container with the required commands to execute.
      #           When using this `custom` type, it is the responsability of this init container
      #           to:
      #           * Extract the downloaded snapshot to the appropriate directory. This chart will
      #             automatically define a default environment variable (POCKETD_WORKING_DIRECTORY_PATH).
      #             (e.g.: tar -vxf snapshot.tar.gz --directory $POCKETD_WORKING_DIRECTORY_PATH/data)
      #
      #          e.g.:
      #          type: custom
      #          image:
      #          repository: amazon/aws-cli
      #          tag: latest
      #          resources:
      #            requests:
      #              cpu:
      #              memory:
      #            limits:
      #              cpu:
      #              memory:
      #          command:
      #            - "/bin/sh"
      #            - "-c"
      #            - |
      #              aws s3 cp s3://your-bucket-name/path/to/snapshot.tar.gz .
      #              tar --no-same-owner -vxf {{ .Values.workingDirectory }}/snapshot/*.tar.zst --directory $POCKETD_WORKING_DIRECTORY/data
      type: ariac
      config:
        # defines the url to download.
        url: https://snapshots.us-nj.poktroll.com/testnet-beta-39120-archival.torrent
        # change pocket data folder owner.
        chownAsUser: 1025
        # change pocket data folder group.
        chownAsGroup: 1025
    # configure the keyring for the fullnode. The keyring holds the private/public keypairs used to
    # interact with a node. If you want to deploy a validator, you need to provide the key before
    # running the node.
    # This chart is only supporting the test backend, and the keyNames must be unique across
    # Kubernetes Secrets to prevent potential side effects, such as one key overwriting another.
    # For more information, please visit https://docs.cosmos.network/main/user/run-node/keyring
    #
    # e.g.:
    # keyring:
    #   secrets:
    #     - name: pocket-network-shannon-validator-keys-1
    #       keyNames:
    #         - 6e4d19771c68484393f8c270b76b0c15.info
    #         - 4d59176f4e1a43a5babf49ac393bdf26.info
    #     - name: pocket-network-shannon-validator-keys-2
    #       keyNames:
    #         - dbc9414ed61b4ac28648947923d0ef6b.info
    keyring: {}
    # volumes are the additional volume for the fullnode pod template.
    volumes: []
    # volumeMounts are the additional volume mount point for the fullnode pod
    # template.
    #
    # e.g:
    #
    # volumeMounts:
    #   - name: foo
    #     mountPath: "/etc/foo"
    #     readOnly: true
    volumeMounts: []
    # livenessProbe configures the mechanism that checks the health of the
    # tendermint consensus layer and the cosmossdk app-level availability.
    livenessProbe:
      # actives the liveness probe for the fullnode Kubernetes Pod.
      enabled: true
      # initial number of seconds to wait after the container starts the 
      # liveness probe.
      initialDelaySeconds: 120
      # defines how often Kubernetes performs health checks in seconds.
      periodSeconds: 15
      # defines a duration threshold for the command to execute before it
      # is considered as failed.
      timeoutSeconds: 5
      # defines how many failures before Kubernetes restart the the container.
      failureThreshold: 5
      # defines how many successful probes before considering it healthy.
      successThreshold: 1
    # resources is the root configuration for the cpu and memory resource
    # limitations.
    resources:
      # preset defines the resource pre-configuration (cpu and memory) for the
      # fullnode (small, medium, large or none).
      preset:
        # activates the preset definition for the fullnode pod template.
        enabled: false
        # select the preset to use for the fullnode pod template.
        name: medium
      # values are the resources requests and limit to used if the preset
      # isn't enabled for the fullnode pod container.
      values:
        # requests defines the minimum resources a container needs to run.
        requests:
          # cpu defines the cpu minimum resources.
          cpu: 8000m
          # memory defines the memory minimum resources.
          memory: 32Gi
        # limits defines the maximum resources a container can use.
        limits:
          # cpu defines the cpu maximum resource.
          cpu: 10000m
          # memory defines the memory maximum resource.
          memory: 38Gi
    # podAnnotations are key-values pairs metadata attched to the fullnode Pods.
    #
    # e.g.
    # podAnnotations:
    #   version: "1.2.3"
    #   commitHash: "abc123def456"
    podAnnotations: {}
    # podSecurityContext are key-values pairs to define the security settings
    # for all containers within a pod.
    #
    # e.g
    # podSecurityContext
    #   runAsUser: 1000         # Run the Pod as user ID 1000
    #   runAsGroup: 3000        # Run the Pod as group ID 3000
    #   fsGroup: 2000           # Set file system group ownership to 2000
    podSecurityContext: {}
    # securityContext are key-values pairs to define the security settings
    # for the fullnode pod containers. This field overwrites the
    # podSecurityContext settings if any defined.
    #
    #
    # e.g.
    # containersSecurityContext
    #   runAsUser: 1025
    #   runAsGroup: 1025
    containersSecurityContext:
      runAsUser: 1025
      runAsGroup: 1025
    # nodeSelector are key-values pairs to schedule the fullnode pod on a
    # specific node based on labels.
    nodeSelector: {}
    # affinity defines the settings for complex scheduling preferences.
    affinity: {}
    # tolerations defines policies for taints.
    tolerations: []
